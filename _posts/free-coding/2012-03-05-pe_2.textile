---
layout: post
category: free-coding
title: Project Euler / Problem 7
description: Mort's solutions to Project Euler (source code released into the Public Domain)
tag: pe
disqus: true
---

h2. Problem 7

By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
What is the 10 001st prime number?

h3. Solution:

My very first solution was defining a recursive function P(n) representing the nth prime number, which tried to divide every integer bigger than P(n-1) incrementally by the value P(1), P(2), ..., P(n-1) to see if it is the next prime number. As n increases, the call stack will explode soon and the algorithm can be intolerably slow. Obviously it is the worst idea to solve the problem.

<script src="https://gist.github.com/1980606.js?file=pe007_1.py"></script>

To improve our algorithm, we employed an array primes[] to store the calculated prime numbers and reconstructed our recursive function into loops. Now the call stack is considerably saved and we have a usable program:

<script src="https://gist.github.com/1980620.js?file=pe007_2.py"></script>

bc. $ time python3 pe007_2.py 
104743
real	0m11.562s
user	0m11.533s
sys	0m0.010s

Keep in mind that in Python, for loop can be used to iterate each element in a list directly. Thus we have a program which runs a little faster:

<script src="https://gist.github.com/1980636.js?file=pe007_3.py"></script>

bc. $ time python3 pe007_3.py 
104743
real	0m8.755s
user	0m8.739s
sys	0m0.003s

When we check if i is a prime number, for each element p in primes[], we only need to look at those $p < \sqrt{i}$ and see if $p | i$. This can save our time a lot!

<script src="https://gist.github.com/1980653.js?file=pe007_4.py"></script>

bc. $ time python3 pe007_4.py 
104743
real	0m0.295s
user	0m0.290s
sys	0m0.003s

Finally, I rewrite the above code in C99:

<script src="https://gist.github.com/1980661.js?file=pe007.c"></script>

bc. $ gcc -o pe007 pe007.c -std=c99 -lm
$ time ./pe007 
104743
real	0m0.008s
user	0m0.007s
sys	0m0.000s

For n = 100001 (the 100 001st prime number), the Python implementation and the equivalent C implementation can differ a lot in time efficiency:

bc. $ time python3 pe007_4.py 
1299721
real	0m6.012s
user	0m6.003s
sys	0m0.000s

bc. $ gcc -o pe007 pe007.c -std=c99 -lm
$ time ./pe007 
1299721
real	0m0.124s
user	0m0.123s
sys	0m0.000s

